layout: true
class: basic, layout, imaging, fonts, lists, cards, fadein, tabler
name: content
<div class="basic header"></div>
<div class="basic footer"><p>CS2030S: Programming Methodology II -- Adi Yoga S. Prabawa</p></div>

---

name: Lecture_03
class: bottom, titles

# CS2030S
## Programming Methodology II
### Lecture 03: Polymorphism

---

name: Recap
class: middle, sections

# Recap

---

# Recap

.ft15.subsections[
### Class Design
]
.ft82[
## Class Design
### Composition & Inheritance
.col51[
.card.bg-g[
### Composition
.content.tight[
A __composition__ captures a _".uline[has a]"_ relationship
]
]

```java
class Circle {
  private Point c;
  // other code omitted
}
```

.card.bg-y[
### Note
.content.tight[
All _public_ methods of `Point` can be called with `c.method(..)` from inside the class `Circle` .note16[(i.e., need to be manually invoked)].
]
]
]
.ft49[
.card.bg-g[
### Inheritance
.content.tight[
An __inheritance__ captures an _".uline[is a]"_ relationship
]
]

```java
class ColouredCircle extends Circle {
  private String colour;
  // other code omitted
}
```

.card.bg-y[
### Note
.content.tight[
All _public_ methods of `Circle` can be called with `this.method(..)` from inside the class `ColouredCircle` .note16[(i.e., automatically inherited)].
]
]
]
]

---

# Recap

.ft15.subsections[
### Class Design
### Method Summary
]
.ft82[
## Method Summary
### Signature & Descriptor
.col51[
.card.bg-b[
### Method Signature
.content.tight[
A __method signature__ includes:
1. The method name
2. The type of arguments
3. The order of arguments
4. The number of arguments
]
]
]
.ft49[
.card.bg-b[
### Method Descriptor
.content.tight[
A __method descriptor__ is the __method signature__ + the return type.
]
]
]
]

.ft82[
#### Steps
.col50[
```java
public boolean contains(int x, int y) {
    :
}
```
]
.ft50[
1. Remove body, modifiers, and parameter name .note16[(method descriptor)]
```java[copy=nones]
boolean contains(int, int)
```
2. Remove return type .note16[(method signature)]
```java[copy=nones|show=2]
boolean
contains(int, int)
```
]
]

---

# Recap

.ft15.subsections[
### Class Design
### Method Summary
### Method Override
]
.ft82[
## Method Override

.card.bg-b[
### Definition
.content.tight[
__Method overriding__ happens when a subclass defines an _instance method_ with the __same method descriptor__ .note16[(as an exception, the overriding method can return the subclass)] as an instance method in the superclass.

<br>

As a good practice, when overriding an instance method in superclass, annotate the method in the subclass with `@Override` annotation.
]
]

#### Example
.col63[
```java
class Circle {
  private Point c;
  private double r;
  
  @Override
  public String toString() {
    return "Circle(" + this.c + ", " + this.r + ")";
  }
}
```
]
.ft37[
.card.bg-y[
### Note
.content.tight[
`toString()` method is automatically called when printing .note16[(i.e., `System.out.println(..)`)] or concatenating with `String` using `+` operator.

<br>

This automatic conversion is not done when assigning to a `String`.
]
]
]
]

---

name: Polymorphism
class: middle, sections

# Polymorphism

---

# Polymorphism

.ft15.subsections[
### Method Overloading
#### Definition
]
.ft82[
## Method Overloading
.card.bg-b[
### Definition
.content.tight[
__Method overloading__ happens when we have _two or more_ methods in the same class .note16[(or inherited from superclass)] with the same name but different _method signature_.

<br>

We cannot overload a method by changing its return type .note16[(i.e., not looking at method descriptor)].
]
]

#### Example
.col63[
```java
class Circle {
    :
  public boolean contains(Point p) {
    // code omitted
  }
  
  public boolean contains(double x, double y) {
    // code omitted
  }
}
```
]
.ft37[
.card.bg-y[
### Note
.content.tight[
We can see the overloading by looking at the method signature:
- `contains(Point)`
- `contains(double, double)`
]
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
#### Definition
#### Quiz
]
.ft82[
## Method Overloading
### Quiz

.qns[
> ##### Question
> Assume we have three classes `A`, `B`, and `C` and consider the method below.
```java
C f(A x, B y) { /* .. */ }
```
> Select ALL the methods that are overloading the method above.
>
> __Hint:__ first determine the method signature.
]

.mrq[
1. .quiz-choice[.font20[`C f(A a, B b)`]] .quiz-ans[0] .quiz-hint[NO: same signature `f(A, B)`]
2. .quiz-choice[.font20[`A f(B x, C y)`]] .quiz-ans[1] .quiz-hint[YES: different signature `f(B, C)`]
1. .quiz-choice[.font20[`A f(A x, B y)`]] .quiz-ans[0] .quiz-hint[NO: still same signature `f(A, B)`]
2. .quiz-choice[.font20[`C f(B x, A y)`]] .quiz-ans[1] .quiz-hint[YES: different signature `f(B, A)`]

.quizzes-poll[OEsuB9bkTdD2n1A7jTa3p]
.quizzes-time[60]
.quizzes-qr[https://www.comp.nus.edu.sg/~adi-yoga/remark/img/QR.png]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
#### Motivation
]
.ft82[
## Polymorphism
### Motivation
```java
void say(Object obj) {
  System.out.println("Hi, I am " + obj.toString());
}
```

#### Problems?
- All classes is a subclass .note16[(directly or indirectly)] of `Object`
    - `Object` has the method `Object::toString()`
    - All classes inherits `Object::toString()`
- The behaviour of `Object::toString()` is fixed
    - Do we need overloaded `say` method for different classes?
    - How do we change the behaviour of `say` without modifying or overloading `say`?
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
#### Motivation
]
.ft82[
## Polymorphism
### Motivation
```java
void say(Object obj) {
  System.out.println("Hi, I am " + obj.toString());
}
```

#### Without Polymorphism
.col62[
```java
void say(Object obj) {
  if (obj instanceof Circle) {
    Circle c = (Circle) obj;
    System.out.println("Hi, I am " + c.toString());
  } else if (obj instanceof Point) {
    Point p = (Point) obj;
    System.out.println("Hi, I am " + p.toString());
  }
    :
}
```
]
.ft38[
.card.bg-y[
### Note
.content.tight[
- `obj instanceof Circle` operator checks if the run-time type of `obj` is a subtype of `Circle`.
- `Circle c = (Circle) obj` explicitly type casted `obj` to type `Circle`.
- If we want to include more types, we need to add more `else if`.
]
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
#### Motivation
]
.ft82[
## Polymorphism
### Motivation
```java
void say(Object obj) {
  System.out.println("Hi, I am " + obj.toString());
}
```

#### With Polymorphism
.col51[
```jshell
jshell> Point p = new Point(0, 0)
p ==> Point(0.0, 0.0)

jshell> say (p)
Hi, I am Point(0.0, 0.0)

jshell> Circle c = new Circle(p, 3)
c ==> Circle(Point(0.0, 0.0), 3.0)

jshell> say(c)
Hi, I am Circle(Point(0.0, 0.0), 3.0)
```
]
.ft49[
.card.bg-y[
### Advantage
.content.tight[
_"Polymorphism enables you to write programs that process objects that share the same superclass __as if they're all objects of that superclass__"_

<br>

.right[Deitel & Deitel]
]
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
#### Motivation
#### equals
]
.ft82[
## Polymorphism
### Object::equals(Object obj)
<iframe src="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" width="950" height="450" frameborder="0"> </iframe>
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
#### Motivation
#### equals
]
.ft82[
## Polymorphism
### Object::equals(Object obj)
.col65[
```jshell[lite=11]
jshell> Circle c1 = new Circle(new Point(0, 0), 10)
c1 ==> Circle(Point(0.0, 0.0), 10.0)

jshell> Circle c2 = new Circle(new Point(0, 0), 10)
c2 ==> Circle(Point(0.0, 0.0), 10.0)

jshell> c1 == c2
$10 ==> false

jshell> c1.equals(c2)
$11 ==> false
```
]
.ft35[
![Huh?](https://c.tenor.com/bygKq3UlHYUAAAAd/what-nick-young.gif)
]
]

.ft82[
.card.bg-y[
### Note
.content.tight[
The `==` operator compares _references_ .note16[(i.e., checking if the two variables are pointing to the same object)] and not checking the _semantics_ of a `Circle`.
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
#### Motivation
#### equals
#### Overloading
]
.ft82[
## Polymorphism
### via Overloading
.col65[
```java
class Circle {
  // code omitted
  public boolean equals(Circle circle) {
      return (circle.c.equals(this.c))
          && (circle.r == this.r);
  }
}
```

#### Testing
```jshell[lite=2]
jshell> c1.equals(c2)
$11 ==> false
```
]
.ft35[
![Huh?](https://c.tenor.com/bygKq3UlHYUAAAAd/what-nick-young.gif)

.card.bg-y[
### Why?
.content.tight[
The mechanism to choose which method to be invoked is called __dynamic binding__, we will discuss that later.
]
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
#### Motivation
#### equals
#### Overloading
#### Overriding
]
.ft82[
## Polymorphism
### via Overriding
.col65[
```java
class Circle {
  // code omitted
  @Override
  public boolean equals(Object obj) {
    if (obj instanceof Circle) {
      Circle circle = (Circle) obj; // unavoidable
      return (circle.c.equals(this.c))
          && (circle.r == this.r);
    }
    return false;
  }
}
```
]
.ft35[
#### Testing
```jshell[lite=2]
jshell> c1.equals(c2)
$11 ==> true
```

.card.bg-y[
### Note
.content.tight[
We have to perform explicit type cast here because `Object` class has no field called `x` and `y`;
]
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
#### Definition
]
.ft82[
## Dynamic Binding
.card.bg-b[
### Definition
.content.tight[
The __dynamic binding__ mechanism is a mechanism to determine which _instance method_ to be invoked according to the _run-time type_ of the target of invocation .note16[(i.e., the run-time type of `obj` in the expression `obj.method(..)`)].

<br>

Dynamic binding is two-part process.
1. __Compile-Time Part__
    - Determine the method descriptor to be invoked.
2. __Run-Time Part__
    - Determine the method implementation based on the retrieved method descriptor in part 1.
]
]

.col51[
.card.bg-y[
### Note
.content.tight[
This is best visualised using class diagram.
]
]
]
.ft49[
.card.bg-r[
### Static Binding
.content.tight[
Dynamic binding is only used for .uline[_instance methods_].
Class methods as well as both class fields and instance fields are not resolved using dynamic binding.
]
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
#### Definition
#### Compile-Time Part
]
.ft82[
## Dynamic Binding
### Compile-Time Part

```java[copy=nones]
obj.foo(arg);
```

#### Steps
.col75[
1. Determine the .uline[_compile-time type_] ___T___ of `obj`.
2. Collect all methods accessible in class ___T___ with the name `foo`<br>.note16[(includes methods signature in superclasses of ___T___)].
    - If there are none, then it is an error.
3. Keep only methods from step 2 that can accept the .uline[_run-time type_] of `arg`<br>.note16[(if there are more than 1 arguments, it must be able to accept all)].
    - If there are none, then it is an error.
4. Find the .uline[_most specific method descriptor_] from step 3.
    - If there are more than one, then it is an error.
    - The method descriptor is to be used in Run-Time Part.
]
.ft25[
.card.bg-y[
### Most Specific
.content.tight[
A method ___M___ is _more specific_ than method ___N___ if the arguments to ___M___ can be passed to ___N___ without compilation error but not the other way around.
]
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
#### Definition
#### Compile-Time Part
#### Run-Time Part
]
.ft82[
## Dynamic Binding
### Run-Time Part

```java[copy=nones]
obj.foo(arg);
```

#### Steps
.col75[
1. Retrieve the .uline[_method descriptor_] found in Compile-Time Part.
2. Determine the .uline[_run-time type_] ___T___ of `obj`.
3. Starting from class ___T___, select the .uline[_nearest_] method implementation with matching .uline[_method descriptor_] in the class hierarchy.
    1. Start from type ___T___.
    2. If found, execute this method implementation.
    3. If not found, continue searching from the superclass of ___T___.
]
.ft25[
.card.bg-y[
### Note
.content.tight[
Normally, the run-time part will not cause any error because Java ensure type safety.
But if the method is not found in step 3 above, then a run-time error will occur.
]
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
#### Definition
#### Compile-Time Part
#### Run-Time Part
#### Example #1
]
.abs.lt70.wt20.top2[
![Example1](img/03-DynamicBinding01.png)
]
.ft82[
## Dynamic Binding
### Example #1
Which method is invoked by the following code?

```java
Circle c1 = new Circle(new Point(0, 0), 1);
Circle c2 = new Circle(new Point(0, 0), 1);
c1.equals(c2);
```

#### Compile-Time Part
1. Accessible methods named `equals` from compile-time type of `c1`?
.nol[
- <input type="text" class="remark-live-input">
]
2. Compatible methods that can accept compile-time type of `c2`?
.nol[
- <input type="text" class="remark-live-input">
]
3. Most specific method?
.nol[
- <input type="text" class="remark-live-input">
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
#### Definition
#### Compile-Time Part
#### Run-Time Part
#### Example #1
]
.abs.lt70.wt20.top2[
![Example1](img/03-DynamicBinding01.png)
]
.ft82[
## Dynamic Binding
### Example #1
Which method is invoked by the following code?

```java
Circle c1 = new Circle(new Point(0, 0), 1);
Circle c2 = new Circle(new Point(0, 0), 1);
c1.equals(c2);
```

#### Run-Time Part
1. Required method descriptor?
.nol[
- <input type="text" class="remark-live-input">
]
2. Nearest method from run-time type of `c1`?
.nol[
- <input type="text" class="remark-live-input">
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
#### Definition
#### Compile-Time Part
#### Run-Time Part
#### Example #1
#### Example #2
]
.abs.lt70.wt20.top2[
![Example1](img/03-DynamicBinding01.png)
]
.ft82[
## Dynamic Binding
### Example #2
Which method is invoked by the following code?

```java[lite=2]
Circle c1 = new Circle(new Point(0, 0), 1);
Object c2 = new Circle(new Point(0, 0), 1);
c1.equals(c2);
```

#### Compile-Time Part
1. Accessible methods named `equals` from compile-time type of `c1`?
.nol[
- <input type="text" class="remark-live-input">
]
2. Compatible methods that can accept compile-time type of `c2`?
.nol[
- <input type="text" class="remark-live-input">
]
3. Most specific method?
.nol[
- <input type="text" class="remark-live-input">
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
#### Definition
#### Compile-Time Part
#### Run-Time Part
#### Example #1
#### Example #2
]
.abs.lt70.wt20.top2[
![Example1](img/03-DynamicBinding01.png)
]
.ft82[
## Dynamic Binding
### Example #2
Which method is invoked by the following code?

```java[lite=2]
Circle c1 = new Circle(new Point(0, 0), 1);
Object c2 = new Circle(new Point(0, 0), 1);
c1.equals(c2);
```

#### Run-Time Part
1. Required method descriptor?
.nol[
- <input type="text" class="remark-live-input">
]
2. Nearest method from run-time type of `c1`?
.nol[
- <input type="text" class="remark-live-input">
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
#### Definition
#### Compile-Time Part
#### Run-Time Part
#### Example #1
#### Example #2
#### Quiz #1
]
.ft82[
## Dynamic Binding
### Quiz #1

.col55[
.qns[
> ##### Question
> Consider the class definition on the right. Which method is invoked by the following code?
```java
C obj = new C();
C arg = new C();
obj.foo(arg);
```
]
]
.ft45[
#### Code
```java
class A { }
class B extends A {
  public void foo(B b) { }
}
class C extends B {
  public void foo(A a) { }
}
```
]

.mrq[
1. .quiz-choice[.font20[`B::foo(B)`]] .quiz-ans[1] .quiz-hint[YES: more specific (although farther in hierarchy)]
2. .quiz-choice[.font20[`C::foo(A)`]] .quiz-ans[0] .quiz-hint[NO: less specific (although nearer in hierarchy)]
1. .quiz-choice[Error] .quiz-ans[0] .quiz-hint[NO: we found a method]

.quizzes-poll[qCkMbx64knWzNSWhuRZfH]
.quizzes-time[30]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
#### Definition
#### Compile-Time Part
#### Run-Time Part
#### Example #1
#### Example #2
#### Quiz #1
#### Quiz #2
]
.ft82[
## Dynamic Binding
### Quiz #2

.col55[
.qns[
> ##### Question
> Consider the class definition on the right. Which method is invoked by the following code?
```java
B obj = new C();
A arg = new C();
obj.foo(arg);
```
]
]
.ft45[
#### Code
```java
class A { }
class B extends A {
  public void foo(B b) { }
}
class C extends B {
  public void foo(A a) { }
}
```
]

.mrq[
1. .quiz-choice[.font20[`B::foo(B)`]] .quiz-ans[0] .quiz-hint[NO: no match for `foo(A)` in class `B` or its superclasses]
2. .quiz-choice[.font20[`C::foo(A)`]] .quiz-ans[0] .quiz-hint[NO: run-time type of `obj` is `B`, so cannot be this]
1. .quiz-choice[Error] .quiz-ans[1] .quiz-hint[YES: no method found]

.quizzes-poll[P5WYiQylPxS5nwQBG5BV8]
.quizzes-time[30]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
### Liskov
#### Definition
]
.ft82[
## Liskov Substitution Principle
.card.bg-b[
### Definition
.content.tight[
The __Liskov substitution principle__ .note16[(abbreviated LSP)] states

<br>

.nol[
- Let ___ϕ(x)___ be a property provable about objects `x` of type ___T___. Then ___ϕ(y)___ should be true for objects `y` of type ___S___ where ___S <: T___.
]

<br>

In other words,

<br>

.nol[
- If ___S___ is a subclass of ___T___, then an object of type ___T___ can be replaced by that of type ___S___ without changing the .uline[_desirable property_] of the program.
]

<br>

In plain terms,

<br>

.nol[
- A .uline[_subclass_] should not break the expectations set by the .uline[_superclass_].
]
]
]

.card.bg-y[
### Desirable Property
.content.tight[
Desirable property may come from (i) test cases, (ii) specification .note16[(usually in English)], (iii) a given code, .note16[etc].
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
### Liskov
#### Definition
#### Example
]
.ft82[
## Liskov Substitution Principle
### Example
#### Code
.col53[
```java
void displayGrade(Module m, double marks) {
  char grade = m.marksToGrade(marks);
  if (grade == 'A') {
    System.out.println("well done!");
  } else if (grade == 'B') {
    System.out.println("good");
  } else if (grade == 'C') {
    System.out.println("okay");
  } else {
    System.out.println("please try again");
  }
}
```
]
.ft47[
.card.bg-y[
### Specification
.content.tight[
`Module::marksToGrade(double)` should return one of the following: `A`, `B`, `C`, or `F`.
]
]

```java
class CSCUMod extends Module {
  public char marksToGrade(double mark) {
    if (mark > 50) {
      return 'S';
    } else {
      return 'U';
    }
  }
}
```
]
]
.abs.lt70.wt28.top2[
.card.bg-r[
### Quick Quiz
.content.tight[
Does `CSCUMod` violates LSP?
]
]
]

---

# Polymorphism

.ft15.subsections[
### Method Overloading
### Polymorphism
### Dynamic Binding
### Liskov
### Prevention
#### final
]
.ft82[
## Inheritance Prevention
### final Keyword

```java
public final class Point { // the class cannot be inherited
  private final double x;  // field x cannot be re-assigned
  private final double y;  //   i.e., set once and never again
  
  @Override
  public final String toString() { // cannot be overridden in subclass
    return "Point(" + this.x + ", " + this.y + ")";
  }
}
```

.card.bg-y[
### Note
.content.tight[
In the above example, `Point` cannot be inherited so automatically `toString` cannot be overridden because there is no subclass.
In this case, the keyword `final` in `Point::toString()` serves no purpose.

<br>

It is useful if the class is not declared with modifier `final`.
]
]
]

---

name: Abstract_Class
class: middle, sections

# Abstract Class

---

# Abstract Class

.ft15.subsections[
### Motivation
#### Initial
]
.ft82[
## Motivation
### Initial
.col51[
#### Class Diagram
![Circle](img/03-Circle.png)
]
.ft49[
#### Usage
```java
double findLargest(Circle[] array) {
  double maxArea = 0;
  for (Circle curr : array) {
    double area = curr.getArea();
    if (area > maxArea) {
      maxArea = area;
    }
  }
  return maxArea;
}
```
]
]

---

# Abstract Class

.ft15.subsections[
### Motivation
#### Initial
#### Generalization
]
.ft82[
## Motivation
### Generalization
.col51[
#### Class Diagram
![Square](img/03-Square.png)
]
.ft49[
#### Usage
```java[lite=1,3]
double findLargest(??????[] array) {
  double maxArea = 0;
  for (?????? curr : array) {
    double area = curr.getArea();
    if (area > maxArea) {
      maxArea = area;
    }
  }
  return maxArea;
}
```
]
]
.abs.lt70.wt28.top2[
.card.bg-r[
### Quick Quiz
.content.tight[
What should be the type in `??????` such that we can accept both `Circle` and `Square` as well as invoking `curr.getArea()`?
]
]
]

---

# Abstract Class

.ft15.subsections[
### Motivation
#### Initial
#### Generalization
#### Problem #1
]
.ft82[
## Motivation
### Problem #1
.col51[
#### Class Diagram
![Square](img/03-Square.png)
]
.ft49[
#### Usage
```java[lite=4]
double findLargest(Object[] array) {
  double maxArea = 0;
  for (Object curr : array) {
    double area = curr.getArea();
    if (area > maxArea) {
      maxArea = area;
    }
  }
  return maxArea;
}
```

.card.bg-r[
### Problem #1
.content.tight[
The class `Object` has no `getArea()` method.
]
]
]
]

---

# Abstract Class

.ft15.subsections[
### Motivation
#### Initial
#### Generalization
#### Problem #1
#### Problem #2
]
.ft82[
## Motivation
### Problem #2
.col51[
#### Class Diagram
![Shape](img/03-Shape.png)
]
.ft49[
#### Usage
```java[lite=4]
double findLargest(Object[] array) {
  double maxArea = 0;
  for (Object curr : array) {
    double area = curr.getArea();
    if (area > maxArea) {
      maxArea = area;
    }
  }
  return maxArea;
}
```

.card.bg-r[
### Problem #2
.content.tight[
What is the "area" of an arbitrary shape?
]
]
]
]

---

# Abstract Class

.ft15.subsections[
### Motivation
### Abstract Class
#### Definition
]
.ft82[
## Abstract Class
.card.bg-b[
### Definition
.content.tight[
An __abstract class__ is a class that cannot be _instantiated_.
It typically represents an abstract concept .note16[(i.e., not concrete, so instantiating it is "unphysical")].

<br>

#### Properties
- Abstract class can be subclasses.
- Abstract class may have fields.
- Abstract class may have abstract methods .note16[(i.e., method without implementation)].
- Abstract class may have non-abstract methods .note16[(i.e., concrete methods)].
- Abstract class is not required to have abstract methods.
- If a class has an abstract method, it must be declared abstract.
]
]

#### Example
```java
abstract class Shape {              // abstract class
  public abstract double getArea(); // abstract method: no implementation
}
```
]

---

# Abstract Class

.ft15.subsections[
### Motivation
### Abstract Class
#### Definition
#### Solution
]
.ft82[
## Abstract Class
### Solution
.col51[
#### Class Diagram
![Abstract](img/03-Abstract.png)
]
.ft49[
#### Usage
```java[lite=4]
double findLargest(Shape[] array) {
  double maxArea = 0;
  for (Shape curr : array) {
    double area = curr.getArea();
    if (area > maxArea) {
      maxArea = area;
    }
  }
  return maxArea;
}
```

.card.bg-y[
### Note
.content.tight[
`new Shape()` gives a compilation error.
]
]
]
]

---

layout: false
class: middle, end, fadein

`jshell> /exit`

`|  Goodbye`